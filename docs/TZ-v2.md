# Техническое задание (ТЗ) — Версия 2.0

## Система учёта сборов средств в Google Sheets
### Балансовая модель (1 семья = 1 ребёнок)

---

## 1. Цель проекта

Создать простую и прозрачную систему учёта родительских взносов на базе Google Sheets с:
- **Балансовой моделью**: платежи пополняют баланс семьи, цели/расходы списывают с баланса
- Поддержкой разных типов целей (регулярные, разовые, целевые сборы)
- Автоматическими расчётами баланса, начислений и задолженностей
- Минимальным порогом входа (без серверов и БД)

---

## 2. Область применения

- Класс/группа до ~30 семей
- Срок эксплуатации — 1+ год (поддержка истории)
- Работа в интерфейсе Google Sheets; логика — Google Apps Script

---

## 3. Ключевые изменения v2.0 (относительно v1.x)

### 3.1. Разделение платежей и целей

**БЫЛО (v1.x):** 
```
Платёж → привязан к конкретному сбору
```

**СТАЛО (v2.0):** 
```
Платёж → пополняет БАЛАНС семьи
              │
              ▼
      ┌───────────────┐
      │ БАЛАНС СЕМЬИ  │ = Σ платежей − Σ списаний
      └───────────────┘
              │
              ▼
Цель/Расход → списывает С БАЛАНСА (начисление)
```

### 3.2. Два режима платежей

| Режим | Описание | Когда использовать |
|-------|----------|-------------------|
| **Свободный платёж** | Пополнение баланса без привязки к цели | Регулярные взносы, авансы |
| **Целевой платёж** | Пополнение + резервирование под цель | Разовые сборы (совместимость с v1) |

### 3.3. Типы операций

| Операция | Влияние на баланс | Примеры |
|----------|-------------------|---------|
| **Платёж (взнос)** | + пополнение | СБП 5000₽, наличные 1000₽ |
| **Целевой расход** | − списание | Новый год, подарок учителю |
| **Регулярный расход** | − списание (периодически) | Ежемесячный фонд класса 500₽ |
| **Возврат** | + пополнение | Возврат излишка, отмена участия |
| **Корректировка** | ± любая | Исправление ошибок |

### 3.4. Новая структура баланса семьи

```
┌─────────────────────────────────────────────────────────────┐
│                     БАЛАНС СЕМЬИ                            │
├─────────────────────────────────────────────────────────────┤
│  Внесено всего        = Σ всех платежей                     │
│  Списано всего        = Σ начислений по закрытым целям      │
│  ─────────────────────────────────────────────────────────  │
│  Текущий баланс       = Внесено − Списано                   │
│  ─────────────────────────────────────────────────────────  │
│  Зарезервировано      = Σ начислений по ОТКРЫТЫМ целям      │
│  Свободный остаток    = Текущий баланс − Зарезервировано    │
│  ─────────────────────────────────────────────────────────  │
│  Задолженность        = MAX(0, −Свободный остаток)          │
└─────────────────────────────────────────────────────────────┘
```

---

## 4. Термины

| Термин | Определение |
|--------|-------------|
| **Семья** | 1 ребёнок (логика «1 семья = 1 ребёнок») |
| **Платёж** | Поступление средств на баланс семьи |
| **Цель (Goal)** | Событие/расход, требующий средств; списывает с баланса |
| **Регулярная цель** | Повторяющийся расход (ежемесячно, ежеквартально) |
| **Разовая цель** | Единовременный расход/сбор |
| **Участие** | Список семей, участвующих в цели |
| **Баланс** | Разница между внесённым и списанным |
| **Резерв** | Сумма под открытые цели (ещё не списана окончательно) |
| **Свободный остаток** | Баланс минус резерв — можно тратить на новые цели |
| **Задолженность** | Недостаток средств для покрытия резерва |

---

## 5. Ограничения и не-цели

- Нет уведомлений/ботов/интеграций
- Нет импорта банковских выписок
- Даты — справочные (не влияют на расчёт баланса, но полезны для отчётов)
- Нет сложной аналитики (только базовые итоги)
- Нет мультивалютности

---

## 6. Требования к функционалу

### 6.1. Структура листов (обновлённая)

| Лист | Назначение | Ключевые поля |
|------|------------|---------------|
| **Инструкция** | Руководство пользователя | — |
| **Семьи** | Справочник семей | family_id, ФИО, контакты, Активен |
| **Платежи** | Все поступления | payment_id, Дата, family_id, Сумма, Способ, goal_id (опц.) |
| **Цели** | Все расходы/сборы | goal_id, Название, Тип, Статус, Режим начисления, Сумма |
| **Участие** | Кто в какой цели | goal_id, family_id, Статус |
| **Баланс** | Сводка по семьям | family_id, Внесено, Списано, Баланс, Резерв, Свободно, Долг |
| **Детализация** | Расшифровка по целям | family_id, goal_id, Начислено, Оплачено |
| **Сводка целей** | Итоги по целям | goal_id, Цель, Собрано, Участников, Остаток |
| **История** | Лог операций (опц.) | Дата, Операция, family_id, goal_id, Сумма |
| **Lists** | Скрытый, для валидаций | Именованные диапазоны |

### 6.2. Лист «Платежи» (обновлённый)

| Поле | Тип | Обязательно | Описание |
|------|-----|-------------|----------|
| payment_id | ID | Авто | PMT001, PMT002, ... |
| Дата | Дата | Да | Дата поступления (справочно) |
| family_id (label) | Выбор | Да | Семья-плательщик |
| Сумма | Число | Да | > 0 |
| Способ | Выбор | Да | СБП / карта / наличные / перевод |
| goal_id (label) | Выбор | **Нет** | Целевой платёж (если указано) |
| Комментарий | Текст | Нет | Примечание |

**Логика:**
- Если `goal_id` пусто → свободный платёж (на баланс)
- Если `goal_id` указан → целевой платёж (пополняет баланс + учитывается в цели)

### 6.3. Лист «Цели» (бывший «Сборы»)

| Поле | Тип | Описание |
|------|-----|----------|
| goal_id | ID | G001, G002, ... |
| Название | Текст | Понятное имя цели |
| Тип цели | Выбор | `разовая` / `регулярная` |
| Периодичность | Выбор | Для регулярных: `ежемесячно` / `ежеквартально` / `ежегодно` |
| Статус | Выбор | `Открыта` / `Закрыта` / `Отменена` |
| Режим начисления | Выбор | См. ниже |
| Параметр суммы | Число | Ставка или общая цель |
| Фиксированный x | Число | Cap для dynamic режимов |
| Дата начала | Дата | Справочно |
| Дедлайн | Дата | Справочно |
| Приоритет списания | Число | 1 = высший (для автосписания) |
| Комментарий | Текст | Описание |

### 6.4. Типы целей

#### Разовая цель
- Единовременный сбор/расход
- После закрытия — фиксируется и не пересчитывается
- Примеры: Новый год, экскурсия, подарок учителю

#### Регулярная цель
- Повторяющееся начисление
- Создаётся экземпляр на каждый период (или авто-начисление)
- Примеры: Фонд класса (ежемесячно 500₽), уборка (ежеквартально)

### 6.5. Режимы начисления (расширенные)

| Режим | Формула | Описание |
|-------|---------|----------|
| `static_per_family` | Начислено = Параметр | Фикс на семью |
| `shared_total_all` | Начислено = T / N | Делим на всех участников |
| `shared_total_by_payers` | Начислено = T / K | Делим между оплатившими |
| `dynamic_by_payers` | Начислено = min(P_i, x) | Water-filling |
| `proportional_by_payers` | Начислено = P_i × (T/ΣP) | Пропорционально взносам |
| `unit_price` | Начислено = floor(P_i/x) × x | Поштучно |
| `voluntary` | Начислено = P_i | Добровольно (сколько внёс — столько списали) |

**Новый режим `voluntary`:**
- Для благотворительных/добровольных сборов
- Нет цели T, нет долга
- Списывается ровно столько, сколько семья внесла целевым платежом

### 6.6. Логика баланса и списания

#### Приоритет списания
```
1. Целевые платежи → на указанную цель (если есть)
2. Свободные средства → по приоритету целей (поле Приоритет)
3. Автосписание при закрытии цели
```

#### Расчёт баланса семьи
```javascript
Внесено_всего = Σ Платежи[family_id].Сумма

Списано_всего = Σ Начислено по ЗАКРЫТЫМ целям

Текущий_баланс = Внесено_всего − Списано_всего

Зарезервировано = Σ Начислено по ОТКРЫТЫМ целям (ожидаемое списание)

Свободный_остаток = Текущий_баланс − Зарезервировано

Задолженность = MAX(0, −Свободный_остаток)
```

#### Пример
```
Семья Ивановых:
  Платежи: 5000₽ (свободный) + 2000₽ (на Новый год)
  Внесено всего: 7000₽
  
  Цели:
    - Новый год (закрыта): начислено 1500₽ → списано 1500₽
    - Фонд января (открыта): начислено 500₽ → резерв
    - Экскурсия (открыта): начислено 800₽ → резерв
  
  Списано всего: 1500₽
  Текущий баланс: 7000 − 1500 = 5500₽
  Зарезервировано: 500 + 800 = 1300₽
  Свободный остаток: 5500 − 1300 = 4200₽
  Задолженность: 0₽
```

### 6.7. Участие в целях

Правила (без изменений):
1. По умолчанию: все активные семьи
2. Если есть явный «Участвует» → только отмеченные
3. «Не участвует» всегда исключает

Дополнительно для v2.0:
- Можно указать **долю участия** (по умолчанию = 1)
- Доля влияет на расчёт в `shared_total_all` и `static_per_family`

### 6.8. Лист «Баланс» (обновлённый)

| Поле | Описание |
|------|----------|
| family_id | ID семьи |
| Имя ребёнка | Из справочника |
| Внесено всего | Σ платежей |
| Списано всего | Σ начислений (закрытые цели) |
| Текущий баланс | Внесено − Списано |
| Зарезервировано | Σ начислений (открытые цели) |
| Свободный остаток | Баланс − Резерв |
| Задолженность | MAX(0, −Свободный остаток) |

### 6.9. Выпадающие списки

| Контекст | Источник |
|----------|----------|
| Платежи: family_id | Все семьи (метка «ФИО (Fxxx)») |
| Платежи: goal_id | Все цели + пусто (метка «Название (Gxxx)») |
| Участие: goal_id | Только открытые цели |
| Участие: family_id | Только активные семьи |

---

## 7. Меню и автоматизация

### 7.1. Меню «💰 Фонды» (обновлённое)

```
💰 Фонды
├── 🔧 Настроить / Пересоздать структуру
├── 🔄 Пересоздать валидации
├── ─────────────
├── 📊 Отчёты и действия
│   ├── 🔄 Пересчитать всё
│   ├── 📈 Быстрая проверка балансов
│   └── ⚠️ Показать ошибки валидации
├── ─────────────
├── ⚙️ Управление данными
│   ├── 🆔 Сгенерировать ID
│   ├── 🔒 Закрыть цель
│   ├── 📋 Дублировать цель
│   └── 🔄 Создать регулярную цель (новый период)
├── ─────────────
├── 🎲 Загрузить пример данных
└── ❓ Справка
```

### 7.2. Новые функции

| Функция | Описание |
|---------|----------|
| `CREATE_REGULAR_GOAL_INSTANCE()` | Создаёт экземпляр регулярной цели на новый период |
| `AUTO_CHARGE_GOAL(goal_id)` | Автоначисление по цели (для регулярных) |
| `TRANSFER_BALANCE(from_family, to_family, amount)` | Перенос баланса между семьями |
| `CLOSE_GOAL_WITH_REFUND(goal_id)` | Закрыть цель с возвратом излишков на баланс |

### 7.3. Кастомные функции для формул

| Функция | Описание |
|---------|----------|
| `BALANCE_FAMILY(family_id)` | Текущий баланс семьи |
| `RESERVED_FAMILY(family_id)` | Зарезервировано под открытые цели |
| `FREE_BALANCE_FAMILY(family_id)` | Свободный остаток |
| `DEBT_FAMILY(family_id)` | Задолженность |
| `PAID_TO_GOAL(family_id, goal_id)` | Сколько внесено на конкретную цель |
| `ACCRUED_FOR_GOAL(family_id, goal_id)` | Начислено по цели |

---

## 8. Сценарии использования

### 8.1. Ежемесячный фонд класса

```
1. Создать цель «Фонд класса — Январь 2025»
   - Тип: регулярная
   - Режим: static_per_family
   - Сумма: 500₽
   - Периодичность: ежемесячно

2. Семьи вносят платежи (свободные или целевые)

3. В конце месяца: Закрыть цель → списание с балансов

4. Создать цель на следующий месяц (или авто)
```

### 8.2. Разовый сбор (Новый год)

```
1. Создать цель «Новый год 2025»
   - Тип: разовая
   - Режим: shared_total_all
   - Сумма: 15000₽

2. Семьи вносят платежи

3. После мероприятия: Закрыть цель
   - Начисления фиксируются
   - Излишки остаются на балансе
```

### 8.3. Добровольный сбор

```
1. Создать цель «Помощь семье Петровых»
   - Тип: разовая
   - Режим: voluntary
   - Сумма: — (не указана)

2. Желающие вносят целевые платежи

3. Закрытие: списано = внесено (без долгов)
```

### 8.4. Поштучная закупка

```
1. Создать цель «Рабочие тетради»
   - Тип: разовая
   - Режим: unit_price
   - Сумма: 12000₽ (общая закупка)
   - Фиксированный x: 400₽ (цена за штуку)

2. Семьи вносят платежи (кратно 400₽ или нет)

3. Списание: только полные единицы
   - Внесено 1000₽ → списано 800₽ (2 шт), 200₽ на балансе
```

---

## 9. Миграция с v1.x

### 9.1. Обзор процесса миграции

```
┌─────────────────────────────────────────────────────────────────┐
│                    ПРОЦЕСС МИГРАЦИИ v1 → v2                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. ДЕТЕКЦИЯ         Определить версию текущей структуры        │
│         ↓                                                       │
│  2. БЭКАП            Создать копию листов (суффикс _backup_v1)  │
│         ↓                                                       │
│  3. ТРАНСФОРМАЦИЯ    Преобразовать структуру и данные           │
│         ↓                                                       │
│  4. ВАЛИДАЦИЯ        Проверить целостность данных               │
│         ↓                                                       │
│  5. ФИНАЛИЗАЦИЯ      Обновить формулы и валидации               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 9.2. Детекция версии

Скрипт определяет версию по наличию характерных признаков:

| Признак | v1.x | v2.0 |
|---------|------|------|
| Лист «Сборы» | ✓ | — |
| Лист «Цели» | — | ✓ |
| Поле `collection_id` в Платежах | ✓ | — |
| Поле `goal_id` в Платежах | — | ✓ |
| Поле `goal_id` опционально | — | ✓ |
| Лист «История» | — | ✓ (опц.) |

```javascript
function detectVersion_() {
  const ss = SpreadsheetApp.getActive();
  const hasCollections = ss.getSheetByName('Сборы') !== null;
  const hasGoals = ss.getSheetByName('Цели') !== null;
  
  if (hasGoals) return '2.0';
  if (hasCollections) return '1.x';
  return 'new'; // Новая таблица
}
```

### 9.3. Создание резервной копии

Перед миграцией создаются копии всех листов с данными:

```javascript
function createMigrationBackup_() {
  const ss = SpreadsheetApp.getActive();
  const timestamp = Utilities.formatDate(new Date(), 'Europe/Moscow', 'yyyyMMdd_HHmm');
  const backupSheets = ['Сборы', 'Платежи', 'Участие', 'Баланс', 'Семьи'];
  
  backupSheets.forEach(name => {
    const sh = ss.getSheetByName(name);
    if (sh) {
      const copy = sh.copyTo(ss);
      copy.setName(`${name}_backup_v1_${timestamp}`);
      copy.hideSheet();
    }
  });
  
  // Записать метаданные миграции
  PropertiesService.getScriptProperties().setProperty('migration_backup', timestamp);
}
```

### 9.4. Трансформация данных

#### 9.4.1. Миграция листа «Сборы» → «Цели»

| Старое поле (v1) | Новое поле (v2) | Преобразование |
|------------------|-----------------|----------------|
| `collection_id` | `goal_id` | `C001` → `G001` |
| `Название сбора` | `Название` | Без изменений |
| `Статус` | `Статус` | `Открыт` → `Открыта`, `Закрыт` → `Закрыта` |
| `Начисление` | `Режим начисления` | Маппинг режимов |
| `Параметр суммы` | `Сумма цели` | Без изменений |
| `Фиксированный x` | `Фиксированный x` | Без изменений |
| — | `Тип цели` | Все → `разовая` (по умолчанию) |
| — | `Периодичность` | — (пусто для разовых) |
| — | `Приоритет списания` | 10 (средний) |

```javascript
function migrateCollectionsToGoals_() {
  const ss = SpreadsheetApp.getActive();
  const shOld = ss.getSheetByName('Сборы');
  if (!shOld) return;
  
  // Читаем старые данные
  const data = shOld.getDataRange().getValues();
  const headers = data[0];
  const rows = data.slice(1);
  
  // Маппинг колонок
  const oldMap = {};
  headers.forEach((h, i) => oldMap[h] = i);
  
  // Преобразуем данные
  const newRows = rows.map(row => {
    const oldId = row[oldMap['collection_id']] || '';
    const newId = oldId.replace(/^C/, 'G'); // C001 → G001
    
    return {
      goal_id: newId,
      name: row[oldMap['Название сбора']] || row[oldMap['Название']] || '',
      type: 'разовая',
      periodicity: '',
      status: convertStatus_(row[oldMap['Статус']]),
      mode: row[oldMap['Начисление']] || 'static_per_family',
      amount: row[oldMap['Параметр суммы']] || 0,
      fixedX: row[oldMap['Фиксированный x']] || '',
      startDate: row[oldMap['Дата начала']] || '',
      deadline: row[oldMap['Дедлайн']] || '',
      priority: 10,
      comment: row[oldMap['Комментарий']] || ''
    };
  });
  
  // Создаём новый лист «Цели»
  createGoalsSheet_(ss, newRows);
  
  // Скрываем старый лист (не удаляем!)
  shOld.hideSheet();
}

function convertStatus_(oldStatus) {
  const map = {
    'Открыт': 'Открыта',
    'Закрыт': 'Закрыта'
  };
  return map[oldStatus] || 'Открыта';
}
```

#### 9.4.2. Миграция листа «Платежи»

| Старое поле (v1) | Новое поле (v2) | Преобразование |
|------------------|-----------------|----------------|
| `payment_id` | `payment_id` | Без изменений |
| `Дата` | `Дата` | Без изменений |
| `family_id (label)` | `family_id (label)` | Без изменений |
| `collection_id (label)` | `goal_id (label)` | Обновить ID и метки |
| `Сумма` | `Сумма` | Без изменений |
| `Способ` | `Способ` | Без изменений |
| `Комментарий` | `Комментарий` | Без изменений |

**Ключевое изменение:** Поле `goal_id` становится опциональным.

```javascript
function migratePayments_() {
  const ss = SpreadsheetApp.getActive();
  const shPay = ss.getSheetByName('Платежи');
  if (!shPay) return;
  
  const data = shPay.getDataRange().getValues();
  const headers = data[0];
  const rows = data.slice(1);
  
  // Найти колонку collection_id (label)
  const colIdx = headers.findIndex(h => 
    h.includes('collection_id') || h.includes('Сбор')
  );
  
  if (colIdx === -1) return;
  
  // Обновить заголовок
  shPay.getRange(1, colIdx + 1).setValue('goal_id (label)');
  
  // Обновить значения: заменить C на G в ID
  const updatedRows = rows.map(row => {
    const oldLabel = String(row[colIdx] || '');
    if (!oldLabel) return row;
    
    // "Новый год (C002)" → "Новый год (G002)"
    const newLabel = oldLabel.replace(/\(C(\d+)\)/, '(G$1)');
    row[colIdx] = newLabel;
    return row;
  });
  
  // Записать обратно
  if (updatedRows.length > 0) {
    shPay.getRange(2, 1, updatedRows.length, headers.length)
         .setValues(updatedRows);
  }
}
```

#### 9.4.3. Миграция листа «Участие»

```javascript
function migrateParticipation_() {
  const ss = SpreadsheetApp.getActive();
  const shPart = ss.getSheetByName('Участие');
  if (!shPart) return;
  
  const data = shPart.getDataRange().getValues();
  const headers = data[0];
  
  // Обновить заголовок
  const colIdx = headers.findIndex(h => h.includes('collection_id'));
  if (colIdx !== -1) {
    shPart.getRange(1, colIdx + 1).setValue('goal_id (label)');
    
    // Обновить значения
    const rows = data.slice(1);
    rows.forEach((row, i) => {
      const oldLabel = String(row[colIdx] || '');
      if (oldLabel) {
        const newLabel = oldLabel.replace(/\(C(\d+)\)/, '(G$1)');
        shPart.getRange(i + 2, colIdx + 1).setValue(newLabel);
      }
    });
  }
}
```

#### 9.4.4. Создание маппинга ID

Для отслеживания соответствия старых и новых ID:

```javascript
function createIdMapping_() {
  const ss = SpreadsheetApp.getActive();
  const props = PropertiesService.getScriptProperties();
  
  // Читаем старые collection_id
  const shOld = ss.getSheetByName('Сборы') || ss.getSheetByName('Сборы_backup_v1');
  if (!shOld) return {};
  
  const data = shOld.getDataRange().getValues();
  const headers = data[0];
  const idCol = headers.findIndex(h => h === 'collection_id');
  
  const mapping = {};
  data.slice(1).forEach(row => {
    const oldId = row[idCol];
    if (oldId) {
      const newId = oldId.replace(/^C/, 'G');
      mapping[oldId] = newId;
    }
  });
  
  // Сохраняем маппинг
  props.setProperty('id_mapping_v1_v2', JSON.stringify(mapping));
  return mapping;
}
```

### 9.5. Валидация миграции

После трансформации выполняется проверка целостности:

```javascript
function validateMigration_() {
  const ss = SpreadsheetApp.getActive();
  const errors = [];
  const warnings = [];
  
  // 1. Проверка: все goal_id уникальны
  const shGoals = ss.getSheetByName('Цели');
  if (shGoals) {
    const ids = getColumnValues_(shGoals, 'goal_id');
    const duplicates = findDuplicates_(ids);
    if (duplicates.length) {
      errors.push(`Дубликаты goal_id: ${duplicates.join(', ')}`);
    }
  }
  
  // 2. Проверка: все платежи ссылаются на существующие цели или пусты
  const shPay = ss.getSheetByName('Платежи');
  const validGoalIds = new Set(getColumnValues_(shGoals, 'goal_id'));
  
  if (shPay) {
    const goalRefs = getColumnValues_(shPay, 'goal_id (label)');
    goalRefs.forEach((ref, i) => {
      if (!ref) return; // Пустое — OK (свободный платёж)
      const id = extractId_(ref);
      if (id && !validGoalIds.has(id)) {
        warnings.push(`Платёж строка ${i+2}: ссылка на несуществующую цель ${id}`);
      }
    });
  }
  
  // 3. Проверка: сохранение сумм
  const oldTotals = calculateOldTotals_();
  const newTotals = calculateNewTotals_();
  
  if (Math.abs(oldTotals.payments - newTotals.payments) > 0.01) {
    errors.push(`Расхождение сумм платежей: было ${oldTotals.payments}, стало ${newTotals.payments}`);
  }
  
  // 4. Проверка: количество записей
  const counts = {
    goals: shGoals ? shGoals.getLastRow() - 1 : 0,
    payments: shPay ? shPay.getLastRow() - 1 : 0
  };
  
  return { errors, warnings, counts };
}
```

### 9.6. Отчёт о миграции

После завершения выводится отчёт:

```javascript
function showMigrationReport_(result) {
  const ui = SpreadsheetApp.getUi();
  
  let report = '📊 ОТЧЁТ О МИГРАЦИИ v1 → v2\n\n';
  
  report += '✅ УСПЕШНО МИГРИРОВАНО:\n';
  report += `   • Целей: ${result.counts.goals}\n`;
  report += `   • Платежей: ${result.counts.payments}\n`;
  report += `   • Участий: ${result.counts.participation || 0}\n\n`;
  
  if (result.warnings.length) {
    report += '⚠️ ПРЕДУПРЕЖДЕНИЯ:\n';
    result.warnings.forEach(w => report += `   • ${w}\n`);
    report += '\n';
  }
  
  if (result.errors.length) {
    report += '❌ ОШИБКИ:\n';
    result.errors.forEach(e => report += `   • ${e}\n`);
    report += '\n';
  }
  
  report += '📁 РЕЗЕРВНЫЕ КОПИИ:\n';
  report += '   Старые листы сохранены с суффиксом _backup_v1\n';
  report += '   Для отката: меню → Миграция → Откатить к v1\n';
  
  ui.alert('Миграция завершена', report, ui.ButtonSet.OK);
}
```

### 9.7. Откат миграции

Возможность вернуться к v1 при проблемах:

```javascript
function rollbackToV1_() {
  const ui = SpreadsheetApp.getUi();
  const confirm = ui.alert(
    'Откат к версии 1.x',
    'Это удалит новые листы (Цели) и восстановит старые (Сборы) из резервной копии.\n\nПродолжить?',
    ui.ButtonSet.YES_NO
  );
  
  if (confirm !== ui.Button.YES) return;
  
  const ss = SpreadsheetApp.getActive();
  const timestamp = PropertiesService.getScriptProperties()
                                     .getProperty('migration_backup');
  
  if (!timestamp) {
    ui.alert('Ошибка', 'Резервная копия не найдена.', ui.ButtonSet.OK);
    return;
  }
  
  // Удалить новые листы
  ['Цели', 'История'].forEach(name => {
    const sh = ss.getSheetByName(name);
    if (sh) ss.deleteSheet(sh);
  });
  
  // Восстановить из бэкапа
  ['Сборы', 'Платежи', 'Участие', 'Баланс'].forEach(name => {
    const backup = ss.getSheetByName(`${name}_backup_v1_${timestamp}`);
    const current = ss.getSheetByName(name);
    
    if (backup) {
      if (current) ss.deleteSheet(current);
      backup.setName(name);
      backup.showSheet();
    }
  });
  
  // Пересоздать валидации v1
  rebuildValidations();
  
  ui.alert('Откат завершён', 'Данные восстановлены до версии 1.x', ui.ButtonSet.OK);
}
```

### 9.8. Пункт меню миграции

```javascript
// Добавить в onOpen()
function addMigrationMenu_() {
  const ui = SpreadsheetApp.getUi();
  const version = detectVersion_();
  
  if (version === '1.x') {
    ui.createMenu('🔄 Миграция')
      .addItem('📦 Мигрировать на v2.0', 'runMigrationV2_')
      .addItem('ℹ️ Информация о миграции', 'showMigrationInfo_')
      .addToUi();
  } else if (version === '2.0') {
    const hasBackup = PropertiesService.getScriptProperties()
                                       .getProperty('migration_backup');
    if (hasBackup) {
      ui.createMenu('🔄 Миграция')
        .addItem('⏪ Откатить к v1.x', 'rollbackToV1_')
        .addItem('🗑️ Удалить резервные копии', 'cleanupBackups_')
        .addToUi();
    }
  }
}
```

### 9.9. Полный процесс миграции (entry point)

```javascript
function runMigrationV2_() {
  const ui = SpreadsheetApp.getUi();
  
  // Подтверждение
  const confirm = ui.alert(
    '🔄 Миграция на версию 2.0',
    'Будет выполнено:\n' +
    '1. Создание резервных копий\n' +
    '2. Переименование «Сборы» → «Цели»\n' +
    '3. Обновление ID (C→G) и полей\n' +
    '4. Добавление новых колонок\n\n' +
    'Продолжить?',
    ui.ButtonSet.YES_NO
  );
  
  if (confirm !== ui.Button.YES) return;
  
  try {
    SpreadsheetApp.getActive().toast('Миграция началась...', '🔄', -1);
    
    // 1. Бэкап
    createMigrationBackup_();
    
    // 2. Создать маппинг ID
    const idMapping = createIdMapping_();
    
    // 3. Миграция данных
    migrateCollectionsToGoals_();
    migratePayments_();
    migrateParticipation_();
    
    // 4. Создать новые листы
    setupBalanceSheetV2_();
    
    // 5. Валидация
    const result = validateMigration_();
    
    // 6. Обновить валидации и формулы
    if (result.errors.length === 0) {
      rebuildValidations();
      refreshAllFormulas_();
    }
    
    // 7. Отчёт
    showMigrationReport_(result);
    
    SpreadsheetApp.getActive().toast('Миграция завершена!', '✅', 5);
    
  } catch (e) {
    SpreadsheetApp.getActive().toast('Ошибка: ' + e.message, '❌', 10);
    Logger.log('Migration error: ' + e.stack);
    
    ui.alert('Ошибка миграции', 
      'Произошла ошибка: ' + e.message + '\n\n' +
      'Данные не были изменены. Резервные копии сохранены.',
      ui.ButtonSet.OK);
  }
}
```

### 9.10. Обратная совместимость

Для плавного перехода старые функции продолжают работать:

```javascript
// Алиасы для обратной совместимости
function PAYED_TOTAL_FAMILY(familyLabelOrId) {
  // Теперь считает сумму всех платежей (без привязки к цели)
  return TOTAL_PAID_FAMILY(familyLabelOrId);
}

function ACCRUED_FAMILY(familyLabelOrId, statusFilter) {
  // Теперь считает начисления по целям
  return TOTAL_ACCRUED_FAMILY(familyLabelOrId, statusFilter);
}

// Маппинг collection_id → goal_id для старых ссылок
function resolveCollectionId_(collectionId) {
  if (!collectionId) return null;
  if (collectionId.startsWith('G')) return collectionId;
  if (collectionId.startsWith('C')) {
    return collectionId.replace(/^C/, 'G');
  }
  return collectionId;
}
```

### 9.11. Чек-лист миграции

| # | Шаг | Автоматически | Требует проверки |
|---|-----|---------------|------------------|
| 1 | Создать бэкап листов | ✓ | |
| 2 | Переименовать Сборы → Цели | ✓ | |
| 3 | Обновить collection_id → goal_id | ✓ | |
| 4 | Добавить новые поля в Цели | ✓ | |
| 5 | Обновить ссылки в Платежах | ✓ | ✓ |
| 6 | Обновить ссылки в Участии | ✓ | ✓ |
| 7 | Создать новую структуру Баланса | ✓ | |
| 8 | Обновить именованные диапазоны | ✓ | |
| 9 | Обновить валидации | ✓ | |
| 10 | Проверить суммы | | ✓ |
| 11 | Проверить формулы | | ✓ |
| 12 | Удалить бэкапы (опционально) | Вручную | |

---

## 10. Нефункциональные требования

| Требование | Описание |
|------------|----------|
| Простота | Работа только в Google Sheets; без кода для пользователя |
| Производительность | До 30 семей, сотни платежей — расчёты < 2 сек |
| Надёжность | Детерминированные формулы; закрытие фиксирует состояние |
| Прозрачность | Понятные листы; минимум скрытой логики |
| Локализация | Интерфейс на русском |
| Аудит | История изменений (опционально) |

---

## 11. Валидации и проверки

| Проверка | Где |
|----------|-----|
| Сумма платежа > 0 | Платежи |
| goal_id из списка или пусто | Платежи |
| family_id существует | Платежи, Участие |
| Баланс ≥ 0 при закрытии цели | Предупреждение |
| Дубликаты ID | Generate IDs |

---

## 12. Тестовые сценарии

### 12.1. Базовые

| # | Сценарий | Ожидание |
|---|----------|----------|
| 1 | Свободный платёж 5000₽ | Баланс +5000, резерв 0, свободно 5000 |
| 2 | Целевой платёж 2000₽ на G001 | Баланс +2000, резерв +начисление по G001 |
| 3 | Закрыть цель | Резерв → Списано; баланс уменьшается |
| 4 | Регулярная цель (новый период) | Новый резерв, старый списан |

### 12.2. Граничные

| # | Сценарий | Ожидание |
|---|----------|----------|
| 5 | Баланс 0, открыта цель на 500₽ | Задолженность 500₽ |
| 6 | Отмена цели | Резерв обнуляется, баланс не меняется |
| 7 | Возврат платежа | Сторно: баланс −сумма |

---

## 13. Этапы реализации

| Этап | Задачи | Приоритет |
|------|--------|-----------|
| 1 | Обновить структуру листов | Высокий |
| 2 | Новые формулы баланса | Высокий |
| 3 | Поддержка свободных платежей | Высокий |
| 4 | Регулярные цели | Средний |
| 5 | История операций | Низкий |
| 6 | Миграция v1 → v2 | Средний |

---

## 14. Риски

| Риск | Митигация |
|------|-----------|
| Сложность для пользователей | Подробная инструкция; режим «как раньше» по умолчанию |
| Ошибки при миграции | Резервное копирование; ручная проверка |
| Производительность | Кэширование; batch-операции |

---

## 15. Критерии успешности

- [ ] Казначей может вносить свободные платежи без указания цели
- [ ] Баланс корректно отражает внесено/списано/резерв/свободно
- [ ] Регулярные цели создаются на новый период одной кнопкой
- [ ] Старые данные (v1) корректно мигрируют
- [ ] Все суммы сходятся при ручной проверке

---

## Приложение A. Сравнение v1 и v2

| Аспект | v1.x | v2.0 |
|--------|------|------|
| Платёж | Привязан к сбору | Свободный или целевой |
| Баланс | Оплачено − Начислено | Внесено − Списано − Резерв |
| Переплата | Глобальная | На уровне баланса (свободный остаток) |
| Регулярные сборы | Вручную | Тип цели + автосоздание |
| Отмена участия | Возврат? | Резерв снимается, баланс остаётся |

---

## Приложение B. Диаграмма потоков

```
                    ┌─────────────┐
                    │   ПЛАТЁЖ    │
                    │  (семья)    │
                    └──────┬──────┘
                           │
              ┌────────────┴────────────┐
              │                         │
              ▼                         ▼
     ┌─────────────────┐      ┌─────────────────┐
     │ Свободный       │      │ Целевой         │
     │ (goal_id пуст)  │      │ (goal_id указан)│
     └────────┬────────┘      └────────┬────────┘
              │                        │
              └───────────┬────────────┘
                          ▼
                 ┌─────────────────┐
                 │  БАЛАНС СЕМЬИ   │
                 │  (пополнение)   │
                 └────────┬────────┘
                          │
         ┌────────────────┼────────────────┐
         │                │                │
         ▼                ▼                ▼
  ┌────────────┐   ┌────────────┐   ┌────────────┐
  │  ЦЕЛЬ 1    │   │  ЦЕЛЬ 2    │   │  ЦЕЛЬ N    │
  │ (открыта)  │   │ (открыта)  │   │ (закрыта)  │
  │  резерв    │   │  резерв    │   │  списано   │
  └────────────┘   └────────────┘   └────────────┘
```

---

*Версия документа: 2.0-draft*
*Дата: 2025-12-10*
