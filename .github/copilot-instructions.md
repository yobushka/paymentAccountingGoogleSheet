# Copilot Instructions (classic)

Эти инструкции направляют GitHub Copilot и Copilot Chat при работе с этим репозиторием Google Apps Script (Google Sheets).

## Контекст проекта
- Тип: Google Apps Script (V8) для учёта платежей в Google Sheets.
- Основной файл: `Code.gs`.
- Главные API: `SpreadsheetApp`, `PropertiesService`, `Utilities`, `Logger`, `UrlFetchApp` (при необходимости).
- Цель: надёжная и быстрая обработка данных таблиц, минимизируя обращения к API Sheets.

## Домен и спецификация (из Instructions)
Продукт: учёт сборов/взносов для класса/группы в Google Sheets.

- 1 семья = 1 ребёнок; сборы задаются целиком (без «статей»).
- Все расчёты — моментальные по текущим данным (дата платежа — справочная).
- Выпадающие списки показывают метки формата «Название (ID)», для вычислений извлекается ID.
- Поддержан динамический режим распределения взносов (dynamic_by_payers) — water-filling с cap x.

### Структура листов
- Инструкция — пользовательские шаги.
- Семьи — справочник семей и контактов (1 строка = 1 семья/ребёнок).
- Сборы — список сборов (режим начисления, суммы, статус, фиксированный x).
- Участие — выбор участников конкретных сборов (опционально).
- Платежи — поступившие суммы (дата — справочная).
- Баланс — начислено/оплачено/переплата/задолженность по семьям.
- DynCalc — служебные расчёты x (опционально).
- Lists (скрытая) — именованные диапазоны для валидаций (открытые сборы, активные семьи и т.п.).

### Модель данных и ID
- family_id → F001, F002, …
- collection_id → C001, C002, …
- payment_id → PMT001, PMT002, …

Поля:
- Семьи: family_id, Ребёнок ФИО, контакты мамы/папы, Активен.
- Сборы: collection_id, Название, Статус (Открыт/Закрыт), Дата начала, Дедлайн, Начисление (режим), Параметр суммы, Фиксированный x, Комментарий.
- Участие: collection_id (label), family_id (label), Статус = «Участвует» | «Не участвует».
- Платежи: payment_id, Дата (информ.), family_id (label), collection_id (label), Сумма (>0), Способ (СБП/карта/наличные), Комментарий.

### Режимы начисления (обязательно)
- static_per_child — фикс на семью (в модели 1 семья = 1 ребёнок).
- shared_total_all — общая сумма T делится на число участников (по 1 доле на семью).
- dynamic_by_payers — цель T «размазывается» между оплатившими с выравниванием cap x (water-filling):
  x такое, что Σ min(P_i, x) = min(T, Σ P_i), где P_i — взнос семьи. Ранние переплаты выравниваются по мере поступления взносов остальных.

### Бизнес-правила участия
- По умолчанию участники сбора — все активные семьи.
- Если в «Участие» есть хотя бы один «Участвует» для сбора → участники = только указанные «Участвует».
- «Не участвует» всегда исключает семью из участников (даже если нет явных «Участвует»).

### Списки и валидации
На скрытом листе Lists формируются именованные диапазоны для выпадающих:
- OPEN_COLLECTIONS_LABELS: только открытые сборы → «Название (Cxxx)»
- COLLECTIONS_LABELS: все сборы → «Название (Cxxx)»
- ACTIVE_FAMILIES_LABELS: только активные семьи → «Ребёнок ФИО (Fxxx)»
- FAMILIES_LABELS: все семьи → «Ребёнок ФИО (Fxxx)»

Правила валидаций по листам:
- «Участие»: collection_id — из OPEN_COLLECTIONS_LABELS; family_id — из ACTIVE_FAMILIES_LABELS.
- «Платежи»: collection_id — из COLLECTIONS_LABELS; family_id — из FAMILIES_LABELS (разрешены закрытые сборы и неактивные семьи для поздних платежей/возвратов при необходимости).
- «Платежи»: Сумма должна быть > 0; даты информационные и не влияют на расчёты.

### Расчёт «Баланс» (логика формул)
Для каждой family_id:
- Начислено: ACCRUED_FAMILY(A2, "OPEN") или "ALL".
- Оплачено: PAYED_TOTAL_FAMILY(A2).
- Переплата: MAX(0, Оплачено − Начислено).
- Задолженность: MAX(0, Начислено − Оплачено).

### Нефункциональные требования
- Прозрачность данных в таблице; минимум скрытой «магии».
- Низкий порог входа: управление через Google Sheets.
- Производительность: ориентир — ~30 семей, десятки сборов/платежей без лагов.
- Совместимость: без внешних библиотек; только Apps Script.

### Функции меню (Apps Script)
В меню Google Sheets → Funds:
- Setup / Rebuild structure — создать/обновить структуру листов, валидации, инструкции.
- Rebuild data validations — пересоздать валидаторы выпадающих списков.
- Generate IDs (all sheets) — автозаполнение пустых ID на ключевых листах.
- Close Collection (fix x & set Closed)
  - dynamic_by_payers: посчитать cap x по water-filling на основании фактических платежей по сбору, записать «Фиксированный x» и поставить Статус=Закрыт.
  - для прочих режимов: записать x = «Параметр суммы» (справочно) и закрыть при необходимости.
- Load Sample Data (separate) — наполнение демо-данными: семьи, сборы, участие, платежи.

### Кастомные функции для ячеек (формулы)
- LABEL_TO_ID(value) — извлекает ID из «Название (ID)» или возвращает исходное, если уже ID.
- PAYED_TOTAL_FAMILY(familyLabelOrId) — сумма всех платежей семьи (по всем сборам).
- ACCRUED_FAMILY(familyLabelOrId, statusFilter) — начислено семье с учётом режимов и участия; statusFilter = "OPEN" (по умолчанию) или "ALL".
- DYN_CAP(T, payments_range) — возвращает cap x для динамического распределения цели T.

## Язык и формат ответов
- Комментарии, сообщения об ошибках и пояснения — на русском, если не указано иное.
- Предлагай завершённые решения без заглушек и «TODO».
- При изменении существующего кода учитывай текущий стиль и не переформатируй несвязанные части.

## Стиль кода (Apps Script / JS)
- Рантайм: V8. Разрешены `const`/`let`, стрелочные функции, шаблонные строки.
- Именование: `camelCase` для переменных и функций, `UpperCamelCase` для классов, КОНСТАНТЫ_В_ВЕРХНЕМ_РЕГИСТРЕ при необходимости.
- Типы/JSDoc: добавляй JSDoc к публичным функциям и сложным структурам.
- Логирование: используй `Logger.log` умеренно, оставляй понятные сообщения.
- Ошибки: бросай `new Error('…')` с контекстом; перехватывай там, где можно восстановиться или нужно обогатить сообщение.

## Архитектура и разбиение на функции
- Разделяй чистую бизнес-логику и I/O с таблицей:
  - Чистые функции: преобразование данных, валидация, агрегация.
  - I/O-слой: чтение/запись диапазонов, триггеры, конфигурация.
- Не полагайся на глобальное состояние. Для конфигурации используй `PropertiesService` (Script/User) с префиксами ключей.
- Точки входа (для меню/триггеров) — небольшие, вызывают чистые функции.

## Производительность (Sheets best practices)
- Минимизируй количество обращений к API:
  - Читай/записывай массивами: `getValues()`/`setValues()` вместо поячейчной обработки.
  - Работай с диапазонами пакетно; избегай циклов с `getValue()/setValue()`.
- Предварительно фильтруй и подготавливай данные в памяти (массивы/объекты).
- Кэширование: при повторяющихся вычислениях рассматривай `CacheService`/`PropertiesService`.

## Валидация и надёжность
- Проверяй входные данные и схемы строк: пустые значения, типы, форматы дат/сумм.
- Обрабатывай пограничные случаи: пустой лист, дубликаты, несовпадение заголовков, нехватка прав.
- Не хардкоди секреты; для токенов/ключей используй свойства сценария.

## Документация и комментарии
- В начале файла/модуля — краткое описание назначения.
- Для экспортируемых функций — JSDoc с `@param`/`@return` и примерами, где уместно.
- Комментарии — поясняют «почему», а не «что».

## Триггеры и меню
- Если предлагаешь триггер: укажи тип (временной, onEdit/onChange), периодичность и что именно он вызывает.
- Для меню: создавай отдельную функцию инициализации меню (`onOpen`) и маленькие хендлеры.

## Тестируемость
- Стремись к чистым функциям, которые можно проверить через `Logger.log` с маленькими фикстурами.
- Для сложной логики добавляй мини-хелперы для локальной проверки на примерах массивов.

## Коммиты и PR
- Маленькие атомарные изменения с понятными сообщениями (англ. или рус.).
- Описывай эффект и риск; указывай, если есть миграция данных/структуры листа.

## Примеры шаблонов

### Шаблон чтения и записи пачками
```js
/**
 * Возвращает все строки как массив объектов по заголовкам.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet
 * @return {Object<string, any>[]} rows
 */
function readRows(sheet) {
  var range = sheet.getDataRange();
  var values = range.getValues();
  if (values.length < 2) return [];
  var headers = values[0];
  return values.slice(1).map(function(row) {
    var obj = {};
    for (var i = 0; i < headers.length; i++) obj[headers[i]] = row[i];
    return obj;
  });
}

/**
 * Перезаписывает данные из массива объектов по заголовкам.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet
 * @param {Object<string, any>[]} rows
 */
function writeRows(sheet, rows) {
  if (!rows || rows.length === 0) return;
  var headers = Object.keys(rows[0]);
  var values = [headers].concat(rows.map(function(r){
    return headers.map(function(h){ return r[h]; });
  }));
  sheet.clearContents();
  sheet.getRange(1, 1, values.length, headers.length).setValues(values);
}
```

### Шаблон безопасной обработки
```js
function withTry(fn, context) {
  try {
    return fn();
  } catch (e) {
    var msg = '[PaymentSheet] ' + (context || 'op') + ' failed: ' + e.message;
    Logger.log(msg);
    throw new Error(msg);
  }
}
```

### Практические подсказки по реализации домена

1) Извлечение ID из метки «Название (ID)»:
```js
/** Возвращает ID из строки «Название (ID)» или исходное значение, если это уже ID */
function labelToId(value) {
  if (value == null) return '';
  var s = String(value).trim();
  var m = s.match(/\(([^)]+)\)\s*$/);
  return m ? m[1] : s;
}
```

2) Расчёт cap x (water-filling) для dynamic_by_payers:
```js
/**
 * Находит x: sum(min(P_i, x)) = S, где S = min(T, sum(P_i)).
 * p — массив взносов (числа >= 0).
 */
function waterFillingCap(T, p) {
  var payments = p.filter(function(v){ return v > 0; }).sort(function(a,b){ return a-b; });
  if (payments.length === 0) return 0;
  var sumP = payments.reduce(function(a,b){ return a+b; }, 0);
  var S = Math.min(T, sumP);
  if (S <= 0) return 0;
  var n = payments.length;
  var prev = 0;
  for (var i = 0; i < n; i++) {
    var next = payments[i];
    var delta = (next - prev) * (i + 1);
    if (S <= delta) return prev + S / (i + 1);
    S -= delta;
    prev = next;
  }
  return prev + S / n;
}
```

3) Генерация последовательных ID на листах:
```js
function nextId(prefix, index, pad) {
  var width = pad || 3;
  var n = String(index);
  while (n.length < width) n = '0' + n;
  return prefix + n;
}
```

## Как использовать эти инструкции
- Copilot/Chat должен следовать этим правилам при генерации кода и ответов.
- Если правила противоречат текущему коду — предлагай минимальные правки, объясняя компромисс.
- Если чего-то не хватает (структура листа, имена столбцов) — делай 1–2 разумные допущения и продолжай, явно пометив их.

## Как запускать (для пользователей)
1) Открыть пустую Google Таблицу → Расширения → Apps Script → вставить `Code.gs` → сохранить.
2) В таблице: Funds → Setup / Rebuild structure.
3) Заполнить «Семьи», создать «Сборы», при необходимости — «Участие».
4) Вносить «Платежи» через выпадающие «Название (ID)».
5) Смотреть «Баланс». Для динамических — «Close Collection».

## Проверки и приёмочные критерии (сводка)
- Setup создаёт все листы, валидации и инструкцию.
- Generate IDs заполняет пустые ID последовательно (F001, C001, PMT001).
- Участие: показывает только открытые сборы и активные семьи (метки «Название (ID)»).
- Платежи: показывает все семьи/сборы (в т.ч. закрытые); сумма > 0.
- static_per_child: участнику начисляется Параметр суммы; «Не участвует» → 0.
- shared_total_all: начисление = T/N для участвующих; исключённые → 0.
- dynamic_by_payers: до закрытия начислено i = min(P_i, x), Close фиксирует x, после закрытия используется зафиксированный x.
- Баланс: Начислено/Оплачено/Переплата/Задолженность корректны и обновляются мгновенно; даты платежей не влияют на суммы.

---
Коротко: предлагай эффективный, пакетный I/O для Sheets, чистые функции для логики, валидацию входов и понятные комментарии на русском.
